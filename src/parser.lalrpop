use std::str::FromStr;

use intaglio::SymbolTable;
use lalrpop_util::ParseError;

use crate::expr::{Expr, Op};
use super::*;

grammar(idents: &mut SymbolTable, ret: Ident, yld: Ident);

match {
	"+", "-", "*", "/", "%", "&", "^", "|", "<<", ">>", "!",
	"==", "!=", "<", ">", "<=", ">=", "&&", "||",
	"=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>=",
	"...", "$", ":",
	"(", ")", "{", "}", "[", "]",
	r"[a-zA-Z_][a-zA-Z0-9_.]*" => identifier,
	r#""([^"]|\.)*""# => string,
	r"-?[0-9]+" => number,
	";", ",",
	"env", "use", "include", "def", "alias", "macro", "pool", "const",
	"return", "yield", "typedef", "struct", "ptr",
	"if", "else", "while", "do", "for", "repeat", "loop",
	r"#asm[^#]*#end" => raw_assembly,

	// Skip whitespace and comments
	r"\s*" => { },
	r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
	r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

pub File = { <Root*> }

Root: Root<'input> = {
	Script => Root::Script(<>),
	Env => Root::Env(<>),
	RawAsm => Root::RawAsm(<>),
	Include => Root::Include(<>),
	Typedef => Root::Typedef(<>),
	Struct => Root::Struct(<>),
}

Script: Script<'input> = {
	<def_start:@L> <r#type:Ident> <name:Ident> <def_end:@R> "{" <body:ScriptStatement*> "}" => {
		Script { def_start, r#type, name, def_end, body }
	}
}

ScriptStatement: ScriptStatement<'input> = {
	<start:@L> <stmt:SimpleStatement> <end:@R> ";" => {
		ScriptStatement { start, end, kind: ScriptStatementKind::SimpleStatement(stmt) }
	},
	If,
	<start:@L> "while" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { start, end, kind: ScriptStatementKind::While { cond, body } }
	},
	"do" "{" <body:ScriptStatement*> "}" <start:@L> "while" <cond:Expr> ";" => {
		ScriptStatement { start, end, kind: ScriptStatementKind::DoWhile { cond, body } }
	},
	<start:@L> "for" <init:SimpleStatement> ";" <cond:Expr> ";" <post_body:SimpleStatement> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { start, end, kind: ScriptStatementKind::For { init, cond, post_body, body } }
	},
	<start:@L> "repeat" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { start, end, kind: ScriptStatementKind::Repeat { cond, body } }
	},
	<start:@L> "loop" <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { start, end, kind: ScriptStatementKind::Loop { body } }
	},
}
If: ScriptStatement<'input> = {
	<start:@L> "if" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement {
			start,
			end,
			kind: ScriptStatementKind::If { cond, body, else_stmt: vec![] },
		}
	},
	<start:@L> "if" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" "else" "{" <else_stmt:ScriptStatement*> "}" => {
		ScriptStatement {
			start,
			end,
			kind: ScriptStatementKind::If { cond, body, else_stmt },
		}
	},
	<start:@L> "if" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" "else" <else_stmt:If> => {
		ScriptStatement {
			start,
			end,
			kind: ScriptStatementKind::If { cond, body, else_stmt: vec![else_stmt] },
		}
	},
}

Env: Env<'input> = {
	"env" <name:Ident> "{" <body:EnvStatement*> "}" => Env { name, body },
}

EnvStatement: EnvStatement<'input> = {
	<start:@L> <kind:EnvStatementKind> <end:@R> ";" => EnvStatement { start, end, kind },
}
EnvStatementKind: EnvStatementKind<'input> = {
	"def" <name:Ident> "(" <args:Comma<DefinitionParam>> ")" => {
		EnvStatementKind::Def { name, args, kind: DefKind::Simple }
	},
	"alias" <name:Ident> "(" <args:Comma<DefinitionParam>> ")" "=" <target:Ident> "(" <target_args:Comma<AliasParam>> ")" => {
		EnvStatementKind::Def { name, args, kind: DefKind::Alias { target, target_args } }
	},
	"macro" <name:Ident> "(" <args:Comma<DefinitionParam>> ")" "=" <target:Ident> => {
		EnvStatementKind::Def { name, args, kind: DefKind::Macro { target } }
	},
	"use" <target:Ident> => EnvStatementKind::Use { target },
	"pool" "=" <size:Expr> => EnvStatementKind::Pool { size },
}

SimpleStatement: SimpleStatement<'input> = {
	Expr => SimpleStatement::Expr(<>),
	<base_type:Ident> <ptr:"ptr"?> <name:Ident> <init:("=" <Expr>)?> => SimpleStatement::VarDecl {
		name,
		r#type: VarType { base_type, is_ptr: ptr.is_some() },
		init,
	},
	<name:Ident> "=" <value:Expr> => SimpleStatement::Assignment { name, value },
	<name:Ident> OpEq <value:Expr> => SimpleStatement::Assignment { name, value: todo!() },
	"return" => SimpleStatement::Expr(Expr::func_call(ret, vec![])),
	"yield" => SimpleStatement::Expr(Expr::func_call(yld, vec![])),
}
OpEq = { // TODO
	"+=",
	"-=",
	"*=",
	"/=",
	"%=",
	"&=",
	"|=",
	"^=",
	"<<=",
	">>=",
}

RawAsm: RawAsm<'input> = {
	raw_assembly => {
		let len = <>.len();
		// Chop off the leading `#asm` and the trailing `#end`.
		RawAsm { contents: &<>[4..len - 4] }
	}
}

Include: Include<'input> = {
	"include" <path:String> => Include { path },
}

Typedef: Typedef = {
	"typedef" <name:Ident> "=" <target:Ident> ";" => Typedef { name, target },
}

Struct: Struct = {
	"struct" <name:Ident> "{" <members:Comma<StructMember>> "}" => Struct { name, members },
}

StructMember: StructMember = {
	<name:Ident> ":" <r#type:Ident> => StructMember { name, r#type },
}

DefinitionParam: DefParam = {
	"return" <name:Ident> => DefParam { name, kind: DefParamKind::Return },
	"const" <name:Ident> => DefParam { name, kind: DefParamKind::Const },
	<name:Ident> => DefParam { name, kind: DefParamKind::Simple },
}

AliasParam: AliasParam<'input> = {
	"$" <i:number> =>? match usize::from_str(i) {
		Ok(idx) => Ok(AliasParam::Placeholder(idx)),
		Err(_) => Err(ParseError::User { error: "Argument index is too large" }),
	},
	<opt_const:"const"?> <expr:Expr> => AliasParam::Expr { is_const: opt_const.is_some(), expr },
}

// ** Expressions **

Expr = { LogicalOr }

LogicalOr: Expr<'input> = {
	<l:LogicalOr> "||" <r:LogicalAnd> => {
		Expr::binary_op(l, r, Op::LogicalOr, |l, r| (l != 0 || r != 0) as i64)
	},
	LogicalAnd,
}

LogicalAnd: Expr<'input> = {
	<l:LogicalAnd> "&&" <r:Compare> => {
		Expr::binary_op(l, r, Op::LogicalAnd, |l, r| (l != 0 && r != 0) as i64)
	},
	Compare,
}

Compare: Expr<'input> = {
	<l:Compare> "==" <r:BinaryOr> => {
		Expr::binary_op(l, r, Op::Equ, |l, r| (l == r) as i64)
	},
	<l:Compare> "!=" <r:BinaryOr> => {
		Expr::binary_op(l, r, Op::NotEqu, |l, r| (l != r) as i64)
	},
	<l:Compare> "<" <r:BinaryOr> => {
		Expr::binary_op(l, r, Op::LessThan, |l, r| (l < r) as i64)
	},
	<l:Compare> "<=" <r:BinaryOr> => {
		Expr::binary_op(l, r, Op::LessThanEqu, |l, r| (l <= r) as i64)
	},
	<l:Compare> ">" <r:BinaryOr> => {
		Expr::binary_op(l, r, Op::GreaterThan, |l, r| (l > r) as i64)
	},
	<l:Compare> ">=" <r:BinaryOr> => {
		Expr::binary_op(l, r, Op::GreaterThanEqu, |l, r| (l >= r) as i64)
	},
	BinaryOr,
}

BinaryOr: Expr<'input> = {
	<l:BinaryOr> "|" <r:BinaryXor> => {
		Expr::binary_op(l, r, Op::BinaryOr, |l, r| l | r)
	},
	BinaryXor,
}

BinaryXor: Expr<'input> = {
	<l:BinaryAnd> "^" <r:BinaryAnd> => {
		Expr::binary_op(l, r, Op::BinaryXor, |l, r| l ^ r)
	},
	BinaryAnd,
}

BinaryAnd: Expr<'input> = {
	<l:BinaryAnd> "&" <r:Shift> => {
		Expr::binary_op(l, r, Op::BinaryAnd, |l, r| l & r)
	},
	Shift,
}

Shift: Expr<'input> = {
	<l:Shift> "<<" <r:Addition> => {
		Expr::binary_op(l, r, Op::ShiftLeft, |l, r| l << r)
	},
	<l:Shift> ">>" <r:Addition> => {
		Expr::binary_op(l, r, Op::ShiftRight, |l, r| l >> r)
	},
	Addition,
}

Addition: Expr<'input> = {
	<l:Addition> "+" <r:Factor> => {
		Expr::binary_op(l, r, Op::Add, |l, r| l + r)
	},
	<l:Addition> "-" <r:Factor> => {
		Expr::binary_op(l, r, Op::Sub, |l, r| l - r)
	},
	Factor,
};

Factor: Expr<'input> = {
	<l:Factor> "*" <r:Unary> => {
		Expr::binary_op(l, r, Op::Mul, |l, r| l * r)
	},
	<l:Factor> "/" <r:Unary> => {
		Expr::binary_op(l, r, Op::Div, |l, r| l / r)
	},
	<l:Factor> "%" <r:Unary> => {
		Expr::binary_op(l, r, Op::Mod, |l, r| l % r)
	},
	Unary,
};

Unary: Expr<'input> = {
	"-" <Term> => Expr::unary_op(<>, Op::Neg, |n| -n),
	"!" <Term> => Expr::unary_op(<>, Op::Cpl, |n| !n),
	"&" <Ident> => Expr::address(<>),
	Term,
};

Term: Expr<'input> = {
	Num => <>.into(),
	String => <>.into(),
	Ident => <>.into(),
	"(" <Expr> ")",
	"[" <Expr> "]" => Expr::deref(<>),
	<i:Ident> "(" <args:Comma<Expr>> ")" => Expr::func_call(i, args)
};

// ** Wrappers around "raw" terminal tokens**/

Num: i64 = {
	number =>? {
		i64::from_str(<>)
			.map_err(|_| ParseError::User {
				error: "Integer is out of range (must be signed 64-bit)"
			})
	},
};

String: &'input str = {
	string => {
		// Chop off the starting and ending quotes.
		let len = <>.len();
		&<>[1..len - 1]
	},
};

Ident: Ident = {
	identifier => Ident(idents.intern(<>).expect("Too many unique identifiers have been generated!")),
};

// ** Macros **

Comma<T>: Vec<T> = {
	<mut v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			v.push(e);
			v
		}
	}
};
