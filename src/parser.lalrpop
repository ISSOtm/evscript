use crate::types::*;
use lalrpop_util::ParseError;

use std::collections::VecDeque;
use std::io::Read;
use std::str::FromStr;

grammar;

match {
	"+", "-", "*", "/", "%", "&", "^", "|", "<<", ">>", "!",
	"==", "!=", "<", ">", "<=", ">=", "&&", "||",
	"=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>=",
	"...", "$", ":",
	"(", ")", "{", "}",
	r"[a-zA-Z_][a-zA-Z0-9_.]*",
	r#""([^"]|\.)*""#,
	r"-?[0-9]+",
	";", ",",
	"env", "use", "include", "def", "alias", "macro", "pool", "terminator",
	"return", "yield", "typedef", "struct",
	"if", "else", "while", "do", "for", "repeat", "loop",
	r"#asm[^#]*#end",

	// Skip whitespace and comments
	r"\s*" => { },
	r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
	r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

pub File = { <Root*> }

Root: Root = {
	<environment:Iden> <name:Iden> "{" <contents:Statement*> "}" => {
		Root::Function( name, Function { environment, contents } )
	},
	"env" <name:Iden> "{" <contents:Statement*> "}" => {
		Root::Environment( name, Environment { contents } )
	},
	r"#asm[^#]*#end" =>? {
		let mut bytes = <>.bytes().collect::<VecDeque<u8>>();
		bytes.pop_front();
		bytes.pop_front();
		bytes.pop_front();
		bytes.pop_front();
		bytes.pop_back();
		bytes.pop_back();
		bytes.pop_back();
		bytes.pop_back();
		let mut result = String::new();
		bytes.read_to_string(&mut result)
			.map_err(|err| ParseError::User {
				error: "Invalid UTF8"
			})?;
		Ok(Root::Assembly(result))
	},
	"include" <path:String> ";" => Root::Include(path),
	"typedef" <name:Iden> "=" <t:Iden> ";" => Root::Typedef { name, t },
	"struct" <name:Iden> "{" <contents:Comma<StructMember>> "}" => Root::Struct { name, contents },
}

StructMember: StructMember = {
	<name:Iden> ":" <t:Iden> => StructMember { name, t },
}

Statement: Statement = {
	"def" <name:Iden> "(" <args:Comma<DefinitionParam>> ")" ";" => {
		Statement::Definition(name, Definition::Def(Def { args, bytecode: 0 }))
	},
	"alias" <name:Iden> "(" <args:Comma<DefinitionParam>> ")" "=" <target:Iden> "(" <target_args:Comma<AliasParam>> ")" ";" => {
		Statement::Definition(name, Definition::Alias(Alias { args, target, target_args }))
	},
	"macro" <name:Iden> "(" <args:Comma<DefinitionParam>> ")" "=" <target:Iden> ";" => {
		Statement::Definition(name, Definition::Macro(Macro { args, target }))
	},
	"use" <env:Iden> ";" => Statement::Use(env),
	"pool" "=" <expr:Expr> ";" => Statement::Pool(expr),

	<expr:Expr> ";" => Statement::Expression(expr),
	<t:Iden> <i:Iden> ";" => Statement::Declaration(t, i),
	<t:Iden> <l:Iden> "=" <r:Expr> ";" => Statement::DeclareAssign(t, l, r),
	Assignment,
	IfContainer,
	"while" <cond:Expr> "{" <contents:Statement*> "}" => Statement::While(cond, contents),
	"do" "{" <contents:Statement*> "}" "while" <cond:Expr> ";" => Statement::Do(cond, contents),
	"for" <pro:Statement> <cond:Expr> ";" <epi:Statement> "{" <contents:Statement*> "}" => Statement::For(Box::new(pro), cond, Box::new(epi), contents),
	"repeat" <cond:Expr> "{" <contents:Statement*> "}" => Statement::Repeat(cond, contents),
	"loop" "{" <contents:Statement*> "}" => Statement::Loop(contents),

	"return" ";" => Statement::Expression(Rpn::Call(String::from("return"), vec![])),
	"yield" ";" => Statement::Expression(Rpn::Call(String::from("yield"), vec![])),
}

DefinitionParam: DefinitionParam = {
	"return" <i:Iden> => DefinitionParam::Return(i),
	Iden => DefinitionParam::Type(<>),
}

AliasParam: AliasParam = {
	"$" <i:r"-?[0-9]+"> =>? Ok(AliasParam::ArgId(usize::from_str(i)
		.map_err(|_| ParseError::User {
			error: "Argument index is too large"
		})?)),
	Expr => AliasParam::Expression(<>),
}

IfContainer: Statement = {
	"if" <cond:Expr> "{" <contents:Statement*> "}" => Statement::If(cond, contents, None),
	"if" <cond:Expr> "{" <contents:Statement*> "}" "else" "{" <else_contents:Statement*> "}" => Statement::If(cond, contents, Some(else_contents)),
	"if" <cond:Expr> "{" <contents:Statement*> "}" "else" <else_contents:IfContainer> => Statement::If(cond, contents, Some(vec![else_contents])),
}

Assignment: Statement = {
	<l:Iden> "=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l, Box::new(r))),
	<l:Iden> "+=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::Add(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "-=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::Sub(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "*=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::Mul(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "/=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::Div(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "%=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::Mod(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "&=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::BinaryAnd(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "|=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::BinaryOr(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "^=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::BinaryXor(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> "<<=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::ShiftLeft(Box::new(Rpn::Variable(l)), Box::new(r))))),
	<l:Iden> ">>=" <r:Expr> ";" => Statement::Expression(Rpn::Set(l.clone(), Box::new(Rpn::ShiftRight(Box::new(Rpn::Variable(l)), Box::new(r))))),
}

Expr = { LogicalOr }

LogicalOr: Rpn = {
	<l:LogicalOr> "||" <r:LogicalAnd> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l != 0 || r != 0) as i64);
			}
		}
		Rpn::LogicalOr(Box::new(l), Box::new(r))
	},
	LogicalAnd,
}

LogicalAnd: Rpn = {
	<l:LogicalAnd> "&&" <r:Compare> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l != 0 && r != 0) as i64);
			}
		}
		Rpn::LogicalAnd(Box::new(l), Box::new(r))
	},
	Compare,
}

Compare: Rpn = {
	<l:Compare> "==" <r:BinaryOr> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l == r) as i64);
			}
		}
		Rpn::Equ(Box::new(l), Box::new(r))
	},
	<l:Compare> "!=" <r:BinaryOr> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l != r) as i64);
			}
		}
		Rpn::NotEqu(Box::new(l), Box::new(r))
	},
	<l:Compare> "<" <r:BinaryOr> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l < r) as i64);
			}
		}
		Rpn::LessThan(Box::new(l), Box::new(r))
	},
	<l:Compare> "<=" <r:BinaryOr> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l <= r) as i64);
			}
		}
		Rpn::LessThanEqu(Box::new(l), Box::new(r))
	},
	<l:Compare> ">" <r:BinaryOr> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l > r) as i64);
			}
		}
		Rpn::GreaterThan(Box::new(l), Box::new(r))
	},
	<l:Compare> ">=" <r:BinaryOr> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed((l >= r) as i64);
			}
		}
		Rpn::GreaterThanEqu(Box::new(l), Box::new(r))
	},
	BinaryOr,
}

BinaryOr: Rpn = {
	<l:BinaryOr> "|" <r:BinaryXor> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l | r);
			}
		}
		Rpn::BinaryOr(Box::new(l), Box::new(r))
	},
	BinaryXor,
}

BinaryXor: Rpn = {
	<l:BinaryAnd> "^" <r:BinaryAnd> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l ^ r);
			}
		}
		Rpn::BinaryXor(Box::new(l), Box::new(r))
	},
	BinaryAnd,
}

BinaryAnd: Rpn = {
	<l:BinaryAnd> "&" <r:Shift> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l & r);
			}
		}
		Rpn::BinaryAnd(Box::new(l), Box::new(r))
	},
	Shift,
}

Shift: Rpn = {
	<l:Shift> "<<" <r:Addition> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l << r);
			}
		}
		Rpn::ShiftLeft(Box::new(l), Box::new(r))
	},
	<l:Shift> ">>" <r:Addition> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l >> r);
			}
		}
		Rpn::ShiftRight(Box::new(l), Box::new(r))
	},
	Addition,
}

Addition: Rpn = {
	<l:Addition> "+" <r:Factor> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l + r);
			}
		}
		Rpn::Add(Box::new(l), Box::new(r))
	},
	<l:Addition> "-" <r:Factor> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l - r);
			}
		}
		Rpn::Sub(Box::new(l), Box::new(r))
	},
	Factor,
};

Factor: Rpn = {
	<l:Factor> "*" <r:Unary> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l * r);
			}
		}
		Rpn::Mul(Box::new(l), Box::new(r))
	},
	<l:Factor> "/" <r:Unary> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l / r);
			}
		}
		Rpn::Div(Box::new(l), Box::new(r))
	},
	<l:Factor> "%" <r:Unary> => {
		if let Rpn::Signed(l) = l {
			if let Rpn::Signed(r) = r {
				return Rpn::Signed(l % r);
			}
		}
		Rpn::Mod(Box::new(l), Box::new(r))
	},
	Unary,
};

Unary: Rpn = {
	"-" <l:Term> => {
		if let Rpn::Signed(i) = l {
			return Rpn::Signed(-i)
		}
		Rpn::Negate(Box::new(l))
	},
	"!" <l:Term> => {
		if let Rpn::Signed(i) = l {
			return Rpn::Signed(!i)
		}
		Rpn::Not(Box::new(l))
	},
	"*" <l:Term> => Rpn::Deref(Box::new(l)),
	"&" <l:Iden> => Rpn::Address(l),
	Term,
};

Term: Rpn = {
	Num,
	String => Rpn::String(<>),
	Iden => Rpn::Variable(<>),
	"(" <Expr> ")",
	<i:Iden> "(" <args:Comma<Expr>> ")" => Rpn::Call(i, args)
};

Num: Rpn = {
	r"-?[0-9]+" =>? Ok(Rpn::Signed(i64::from_str(<>)
		.map_err(|_| ParseError::User {
			error: "Integer is too large (maximum of 64 bits, signed)"
		})?)),
};

Iden: String = {
	r"[a-zA-Z_][a-zA-Z0-9_.]*" => String::from(<>),
};

String: String = {
	r#""([^"]|\.)*""# =>? {
		let mut bytes = <>.bytes().collect::<VecDeque<u8>>();
		bytes.pop_front();
		bytes.pop_back();
		let mut result = String::new();
		bytes.read_to_string(&mut result)
			.map_err(|err| ParseError::User {
				error: "Invalid UTF8"
			})?;
		Ok(result)
	},
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
