use std::str::FromStr;

use lalrpop_util::ParseError;
use string_interner::StringInterner;

use crate::expr::{Expr, Op};
use super::*;

grammar(idents: &mut StringInterner);

match {
	"+", "-", "*", "/", "%", "&", "^", "|", "<<", ">>", "!",
	"==", "!=", "<", ">", "<=", ">=", "&&", "||",
	"=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>=",
	"...", "$", ":",
	"(", ")", "{", "}", "[", "]",
	r"[a-zA-Z_][a-zA-Z0-9_.]*" => identifier,
	r#""([^"]|\.)*""# => string,
	r"-?[0-9]+" => number,
	";", ",",
	"env", "use", "include", "def", "alias", "macro", "pool", "const",
	"return", "yield", "typedef", "struct", "ptr",
	"if", "else", "while", "do", "for", "repeat", "loop",
	r"#asm[^#]*#end" => raw_assembly,

	// Skip whitespace and comments
	r"\s*" => { },
	r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
	r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

pub File = { <Root*> }

Root: Root<'input> = {
	Script => Root::Script(<>),
	Env => Root::Env(<>),
	RawAsm => Root::RawAsm(<>),
	Include => Root::Include(<>),
	Typedef => Root::Typedef(<>),
	Struct => Root::Struct(<>),
}

Script: Script<'input> = {
	<start:@L> <r#type:Ident> <name:Ident> <end:@R> "{" <body:ScriptStatement*> "}" => {
		Script { span: (start, end), r#type, name, body }
	}
}

ScriptStatement: ScriptStatement<'input> = {
	<start:@L> <stmt:SimpleStatement> <end:@R> ";" => {
		ScriptStatement { span: (start, end), kind: ScriptStatementKind::SimpleStatement(stmt) }
	},
	If,
	<start:@L> "while" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { span: (start, end), kind: ScriptStatementKind::While { cond, body } }
	},
	"do" "{" <body:ScriptStatement*> "}" <start:@L> "while" <cond:Expr> <end:@R> ";" => {
		ScriptStatement { span: (start, end), kind: ScriptStatementKind::DoWhile { cond, body } }
	},
	<start:@L> "for" <init:SimpleStatement> ";" <cond:Expr> ";" <post_body:SimpleStatement> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { span: (start, end), kind: ScriptStatementKind::For { init, cond, post_body, body } }
	},
	<start:@L> "repeat" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { span: (start, end), kind: ScriptStatementKind::Repeat { cond, body } }
	},
	<start:@L> "loop" <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement { span: (start, end), kind: ScriptStatementKind::Loop { body } }
	},
}
If: ScriptStatement<'input> = {
	<start:@L> "if" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" => {
		ScriptStatement {
			span: (start, end),
			kind: ScriptStatementKind::If { cond, body, else_stmt: vec![] },
		}
	},
	<start:@L> "if" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" "else" "{" <else_stmt:ScriptStatement*> "}" => {
		ScriptStatement {
			span: (start, end),
			kind: ScriptStatementKind::If { cond, body, else_stmt },
		}
	},
	<start:@L> "if" <cond:Expr> <end:@R> "{" <body:ScriptStatement*> "}" "else" <else_stmt:If> => {
		ScriptStatement {
			span: (start, end),
			kind: ScriptStatementKind::If { cond, body, else_stmt: vec![else_stmt] },
		}
	},
}

Env: Env<'input> = {
	<start:@L> "env" <name:Ident> <end:@R> "{" <body:EnvStatement*> "}" => Env { span: (start, end), name, body },
}

EnvStatement: EnvStatement<'input> = {
	<start:@L> <kind:EnvStatementKind> <end:@R> ";" => EnvStatement { span: (start, end), kind },
}
EnvStatementKind: EnvStatementKind<'input> = {
	"def" <name:Ident> "(" <args:Comma<DefinitionParam>> ")" => {
		EnvStatementKind::Def { name, args, kind: DefKind::Simple }
	},
	"alias" <name:Ident> "(" <args:Comma<DefinitionParam>> ")" "=" <target:Ident> "(" <target_args:Comma<AliasParam>> ")" => {
		EnvStatementKind::Def { name, args, kind: DefKind::Alias { target, target_args } }
	},
	"macro" <name:Ident> "(" <args:Comma<DefinitionParam>> ")" "=" <target:Ident> => {
		EnvStatementKind::Def { name, args, kind: DefKind::Macro { target } }
	},
	"use" <target:Ident> => EnvStatementKind::Use { target },
	"pool" "=" <size:Expr> => EnvStatementKind::Pool { size },
}

SimpleStatement: SimpleStatement<'input> = {
	Expr => SimpleStatement::Expr(<>),
	<base_type:Ident> <ptr:"ptr"?> <name:Ident> <init:("=" <Expr>)?> => SimpleStatement::VarDecl {
		name,
		r#type: VarType { base_type, is_ptr: ptr.is_some() },
		init,
	},
	<name:Ident> "=" <value:Expr> => SimpleStatement::Assignment { name, value },
	<name:Ident> <op:OpEq> <value:Expr> => SimpleStatement::Assignment {
		name,
		value: Expr::binary_op(name.into(), value, op, |_lhs, _rhs| {
			panic!("Ops involving vars are not supposed to be constant!!")
		}),
	},
	"return" => SimpleStatement::Expr(Expr::ret()),
	"yield" => SimpleStatement::Expr(Expr::yld()),
}
OpEq: OpConstructor<'input> = {
	"+=" => Op::Add,
	"-=" => Op::Sub,
	"*=" => Op::Mul,
	"/=" => Op::Div,
	"%=" => Op::Mod,
	"&=" => Op::BinaryAnd,
	"|=" => Op::BinaryOr,
	"^=" => Op::BinaryXor,
	"<<=" => Op::ShiftLeft,
	">>=" => Op::ShiftRight,
}

RawAsm: RawAsm<'input> = {
	raw_assembly => {
		let len = <>.len();
		// Chop off the leading `#asm` and the trailing `#end`.
		RawAsm { contents: &<>[4..len - 4] }
	}
}

Include: Include<'input> = {
	"include" <path:String> => Include { path },
}

Typedef: Typedef = {
	"typedef" <name:Ident> "=" <target:Ident> ";" => Typedef { name, target },
}

Struct: Struct = {
	"struct" <name:Ident> "{" <members:Comma<StructMember>> "}" => Struct { name, members },
}

StructMember: StructMember = {
	<name:Ident> ":" <r#type:Ident> => StructMember { name, r#type },
}

DefinitionParam: DefParam = {
	"return" <name:Ident> => DefParam { name, kind: DefParamKind::Return },
	"const" <name:Ident> => DefParam { name, kind: DefParamKind::Const },
	<name:Ident> => DefParam { name, kind: DefParamKind::Simple },
}

AliasParam: AliasParam<'input> = {
	"$" <i:number> =>? match usize::from_str(i) {
		Ok(idx) => Ok(AliasParam::Placeholder(idx)),
		Err(_) => Err(ParseError::User { error: "Argument index is too large" }),
	},
	<opt_const:"const"?> <expr:Expr> => AliasParam::Expr { is_const: opt_const.is_some(), expr },
}

// ** Expressions **

Expr = { LogicalOr }

LogicalOr: Expr<'input> = {
	<lhs:LogicalOr> "||" <rhs:LogicalAnd> => Expr::binary_op(lhs, rhs, Op::LogicalOr, |lhs, rhs| (lhs != 0 || rhs != 0) as i64),
	LogicalAnd,
}

LogicalAnd: Expr<'input> = {
	<lhs:LogicalAnd> "&&" <rhs:Compare> => Expr::binary_op(lhs, rhs, Op::LogicalAnd, |lhs, rhs| (lhs != 0 && rhs != 0) as i64),
	Compare,
}

Compare: Expr<'input> = {
	<lhs:Compare> "==" <rhs:BinaryOr> => Expr::binary_op(lhs, rhs, Op::Equ, |lhs, rhs| (lhs == rhs) as i64),
	<lhs:Compare> "!=" <rhs:BinaryOr> => Expr::binary_op(lhs, rhs, Op::NotEqu, |lhs, rhs| (lhs != rhs) as i64),
	<lhs:Compare> "<" <rhs:BinaryOr> => Expr::binary_op(lhs, rhs, Op::LessThan, |lhs, rhs| (lhs < rhs) as i64),
	<lhs:Compare> "<=" <rhs:BinaryOr> => Expr::binary_op(lhs, rhs, Op::LessThanEqu, |lhs, rhs| (lhs <= rhs) as i64),
	<lhs:Compare> ">" <rhs:BinaryOr> => Expr::binary_op(lhs, rhs, Op::GreaterThan, |lhs, rhs| (lhs > rhs) as i64),
	<lhs:Compare> ">=" <rhs:BinaryOr> => Expr::binary_op(lhs, rhs, Op::GreaterThanEqu, |lhs, rhs| (lhs >= rhs) as i64),
	BinaryOr,
}

BinaryOr: Expr<'input> = {
	<lhs:BinaryOr> "|" <rhs:BinaryXor> => Expr::binary_op(lhs, rhs, Op::BinaryOr, |lhs, rhs| lhs | rhs),
	BinaryXor,
}

BinaryXor: Expr<'input> = {
	<lhs:BinaryAnd> "^" <rhs:BinaryAnd> => Expr::binary_op(lhs, rhs, Op::BinaryXor, |lhs, rhs| lhs ^ rhs),
	BinaryAnd,
}

BinaryAnd: Expr<'input> = {
	<lhs:BinaryAnd> "&" <rhs:Shift> => Expr::binary_op(lhs, rhs, Op::BinaryAnd, |lhs, rhs| lhs & rhs),
	Shift,
}

Shift: Expr<'input> = {
	<lhs:Shift> "<<" <rhs:Addition> => Expr::binary_op(lhs, rhs, Op::ShiftLeft, |lhs, rhs| lhs << rhs),
	<lhs:Shift> ">>" <rhs:Addition> => Expr::binary_op(lhs, rhs, Op::ShiftRight, |lhs, rhs| lhs >> rhs),
	Addition,
}

Addition: Expr<'input> = {
	<lhs:Addition> "+" <rhs:Factor> => Expr::binary_op(lhs, rhs, Op::Add, |lhs, rhs| lhs + rhs),
	<lhs:Addition> "-" <rhs:Factor> => Expr::binary_op(lhs, rhs, Op::Sub, |lhs, rhs| lhs - rhs),
	Factor,
};

Factor: Expr<'input> = {
	<lhs:Factor> "*" <rhs:Unary> => Expr::binary_op(lhs, rhs, Op::Mul, |lhs, rhs| lhs * rhs),
	<lhs:Factor> "/" <rhs:Unary> => Expr::binary_op(lhs, rhs, Op::Div, |lhs, rhs| lhs / rhs),
	<lhs:Factor> "%" <rhs:Unary> => Expr::binary_op(lhs, rhs, Op::Mod, |lhs, rhs| lhs % rhs),
	Unary,
};

Unary: Expr<'input> = {
	"-" <Term> => Expr::unary_op(<>, Op::Neg, |n| -n),
	"!" <Term> => Expr::unary_op(<>, Op::Cpl, |n| !n),
	"&" <Ident> => Expr::address(<>),
	Term,
};

Term: Expr<'input> = {
	Num => <>.into(),
	String => <>.into(),
	Ident => <>.into(),
	"(" <Expr> ")",
	"[" <Expr> "]" => Expr::deref(<>),
	<i:Ident> "(" <args:Comma<Expr>> ")" => Expr::func_call(i, args)
};

// ** Wrappers around "raw" terminal tokens**/

Num: i64 = {
	number =>? {
		i64::from_str(<>)
			.map_err(|_| ParseError::User {
				error: "Integer is out of range (must be signed 64-bit)"
			})
	},
};

String: &'input str = {
	string => {
		// Chop off the starting and ending quotes.
		let len = <>.len();
		&<>[1..len - 1]
	},
};

Ident: Ident = {
	identifier => idents.get_or_intern(<>),
};

// ** Macros **

Comma<T>: Vec<T> = {
	<mut v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			v.push(e);
			v
		}
	}
};
